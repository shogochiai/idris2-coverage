# idris2-coverage

**Code coverage library** for Idris2. Parses Chez Scheme profiler output to extract expression coverage, branch coverage, and generate actionable test hints.

Provides two integration modes:
- **Analysis-only**: Parse existing `.ss.html` files (low-level API)
- **Unified Runner**: Run tests with profiling and get coverage in one call (high-level API)

## Quick Start: Unified Runner (Recommended)

```idris
import Coverage.UnifiedRunner
import Coverage.Types

main : IO ()
main = do
  result <- runTestsWithCoverage "." ["My.Tests.AllTests"] 120
  case result of
    Left err => putStrLn $ "Error: " ++ err
    Right report => do
      putStrLn $ "Tests: " ++ show report.passedTests ++ "/" ++ show report.totalTests
      putStrLn $ "Branch coverage: " ++ show report.branchCoverage.branchPercent ++ "%"
```

The Unified Runner handles all Scheme/.ss.html complexity internally:
1. Generates temp test runner with `--profile`
2. Builds and executes
3. Parses coverage from `.ss.html`
4. Cleans up temp files
5. Returns `TestCoverageReport`

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│  Option A: Unified Runner (HIGH-LEVEL)                      │
│  runTestsWithCoverage "." ["Tests.AllTests"] 120            │
│    → TestCoverageReport (tests + branch coverage)           │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│  Option B: Analysis Only (LOW-LEVEL)                        │
│  YOUR TEST RUNNER generates .ss.html                        │
│    → idris2-coverage parses and analyzes                    │
└─────────────────────────────────────────────────────────────┘
```

## Features

- **Expression Coverage**: Per-expression execution counts from Chez Scheme profiler
- **Branch Coverage**: Analyzes `if`/`case`/`cond` constructs to find untested paths
- **Test Hints**: Generates actionable suggestions for improving coverage
- **Function Mapping**: Associates Scheme code back to Idris function names
- **JSON/Text Output**: Machine-readable and human-readable formats

## Requirements

- Idris2 0.8.0+
- Chez Scheme 10.0+ (for profile data generation)

## Installation

```bash
git clone https://github.com/user/idris2-coverage
cd idris2-coverage
idris2 --build idris2-coverage.ipkg
```

## Integration Guide

### Step 1: Generate Profile Data (Your Responsibility)

idris2-coverage **requires** a `.ss.html` file generated by Chez Scheme's profiler.

```bash
# Build your test module with profiling enabled
idris2 --build myproject.ipkg --cg chez --profile

# Run the executable (this generates .ss.html)
./build/exec/mytest

# Result: mytest.ss.html in current directory
```

The `.ss.html` file contains annotated Scheme source with execution counts:
```html
<span class=pc2 title="line 42 char 3 count 15">(if condition ...</span>
```

### Step 2: Analyze with idris2-coverage

#### As a Library (Recommended)

```idris
import Coverage.Types
import Coverage.Collector
import Coverage.TestHint

analyzeCoverage : String -> String -> IO ()
analyzeCoverage ssHtmlPath ssPath = do
  -- Read files
  Right html <- readFile ssHtmlPath | Left _ => putStrLn "Error"
  Right ss <- readFile ssPath | Left _ => putStrLn "Error"

  -- Parse function definitions (for mapping)
  let funcDefs = parseSchemeDefs ss

  -- Parse branch coverage
  let branchPoints = parseBranchCoverage html
  let summary = summarizeBranchCoverageWithFunctions funcDefs branchPoints

  -- Generate hints
  let hints = generateBranchHints summary
  let hintSummary = summarizeBranchHints hints

  -- Output
  putStrLn $ "Branch Coverage: " ++ show summary.branchPercent ++ "%"
  putStrLn $ branchHintsToText hintSummary
```

#### As a CLI Tool

```bash
# Generate JSON report
./build/exec/idris2-cov --format json --output coverage.json mytest.ss.html

# Generate text report
./build/exec/idris2-cov --format text mytest.ss.html
```

## API Reference

### Unified Runner (High-Level)

```idris
-- From Coverage.UnifiedRunner

-- Run tests with profiling and return combined report
runTestsWithCoverage : (projectDir : String)
                     -> (testModules : List String)
                     -> (timeout : Nat)
                     -> IO (Either String TestCoverageReport)

-- Test modules must export: runAllTests : IO ()
-- Output format: [PASS] TestName or [FAIL] TestName: message
```

```idris
-- From Coverage.Types

-- Individual test result
record TestResult where
  constructor MkTestResult
  testName : String
  passed   : Bool
  message  : Maybe String

-- Combined test and coverage report
record TestCoverageReport where
  constructor MkTestCoverageReport
  testResults     : List TestResult
  totalTests      : Nat
  passedTests     : Nat
  failedTests     : Nat
  branchCoverage  : BranchCoverageSummary
  timestamp       : String
```

### Core Types

```idris
-- Branch coverage types
data BranchType = IfBranch | CaseBranch | CondBranch

record BranchPoint where
  line, char      : Nat
  branchType      : BranchType
  totalBranches   : Nat        -- 2 for if, N for case/cond
  coveredBranches : Nat
  branchDetails   : List (String, Nat)

record BranchCoverageSummary where
  totalBranchPoints : Nat
  totalBranches     : Nat
  coveredBranches   : Nat
  branchPercent     : Double
  uncoveredBranches : List (String, BranchPoint)  -- (funcName, point)

-- Test hint types
record BranchHint where
  schemeFunc     : String      -- Function name
  branchLine     : Nat         -- Line in Scheme source
  branchType     : String      -- "if", "case", "cond"
  uncoveredPath  : String      -- "else-branch not taken"
  suggestedInput : String      -- "Provide input where condition is FALSE"
  priority       : HintPriority
  rationale      : String
```

### Parsing Functions

```idris
-- From Coverage.Collector

-- Parse Scheme function definitions (for name mapping)
parseSchemeDefs : String -> List (String, Nat)

-- Parse branch coverage from annotated HTML
parseBranchCoverage : String -> List BranchPoint

-- Summarize without function name mapping
summarizeBranchCoverage : List BranchPoint -> BranchCoverageSummary

-- Summarize with function name mapping (recommended)
summarizeBranchCoverageWithFunctions : List (String, Nat) -> List BranchPoint -> BranchCoverageSummary
```

### Hint Generation

```idris
-- From Coverage.TestHint

-- Generate hints from coverage summary
generateBranchHints : BranchCoverageSummary -> List BranchHint

-- Summarize hints by priority
summarizeBranchHints : List BranchHint -> BranchHintSummary

-- Output formats
branchHintsToText : BranchHintSummary -> String
branchHintsToJson : List BranchHint -> String
branchHintToJson  : BranchHint -> String
```

### Report Generation

```idris
-- From Coverage.Report

branchCoverageSummaryJson : BranchCoverageSummary -> String
branchPointJson : BranchPoint -> String

-- From Coverage.Aggregator
aggregateProjectWithBranches : List ModuleCoverage -> BranchCoverageSummary -> ProjectCoverage
```

## Output Formats

### Coverage Granularity

idris2-coverage outputs coverage at three levels for actionable insights:

```
┌─────────────────────────────────────────────────────────────┐
│  Project Level (aggregate)                                  │
│    total_functions: 42, covered_functions: 35 (83.3%)       │
├─────────────────────────────────────────────────────────────┤
│  Module Level (per-file breakdown)                          │
│    src/Foo.idr: 10/12 functions (85.0%)                     │
│    src/Bar.idr: 25/30 functions (80.0%)                     │
├─────────────────────────────────────────────────────────────┤
│  Function Level (most granular)                             │
│    Foo.process: 100% ← called by [test_process]             │
│    Foo.validate: 0%  ← NOT TESTED                           │
│    Bar.transform: 75% ← called by [test_transform]          │
└─────────────────────────────────────────────────────────────┘
```

### Full Coverage Report (JSON)

```json
{
  "functions": [
    {
      "module": "Sample",
      "name": "add",
      "signature": "Int -> Int -> Int",
      "line_start": 5,
      "line_end": 6,
      "covered_lines": 2,
      "total_lines": 2,
      "coverage_percent": 100.0,
      "called_by_tests": ["test_add"]
    },
    {
      "module": "Sample",
      "name": "unused",
      "signature": "Int -> Int",
      "line_start": 18,
      "line_end": 19,
      "covered_lines": 0,
      "total_lines": 2,
      "coverage_percent": 0.0,
      "called_by_tests": []
    }
  ],
  "modules": [
    {
      "path": "src/Sample.idr",
      "functions_total": 4,
      "functions_covered": 3,
      "line_coverage_percent": 75.0
    }
  ],
  "project": {
    "total_functions": 4,
    "covered_functions": 3,
    "line_coverage_percent": 75.0,
    "branch_coverage_percent": 33.6
  }
}
```

### Coverage Report (Text)

```
=== Coverage Report ===

Project Summary:
  Functions: 3/4 covered
  Line Coverage: 75.0%
  Branch Coverage: 33.6%

Modules:
  src/Sample.idr: 3/4 (75.0%)

Uncovered Functions:
  Sample.unused (line 18)
```

### Branch Coverage Summary (JSON)

```json
{
  "total_branch_points": 217,
  "total_branches": 446,
  "covered_branches": 150,
  "branch_percent": 33.63
}
```

### Branch Hint (JSON)

```json
{
  "function": "PreludeC-45Types-u--foldr_Foldable_List",
  "line": 732,
  "branch_type": "if",
  "uncovered_path": "else-branch not taken",
  "suggested_input": "Provide input where condition is FALSE",
  "priority": "IMPORTANT",
  "rationale": "The false-case of this if expression was never executed"
}
```

### Human-Readable Output

```
=== Branch Coverage Improvement Hints ===

Uncovered branches: 56

--- IMPORTANT (should fix) ---
  * blodwen-lazy (line 43)
    Problem: else-branch not taken
    Solution: Provide input where condition is FALSE

  * PreludeC-45Types-u--foldr_Foldable_List (line 732)
    Problem: else-branch not taken
    Solution: Provide input where condition is FALSE
```

## Integration Example: lazy-idris

lazy-idris uses idris2-coverage for TI Parity (Test-Implementation Parity) checks.

### Data Flow

```
lazy-idris audit
    │
    ├── Step 1-4: ST/SI Parity checks
    │
    ├── Step 5: TI Parity (Code Coverage)
    │   │
    │   ├── 5a. Build with profiling     [lazy-idris responsibility]
    │   │       idris2 --build --cg chez --profile
    │   │
    │   ├── 5b. Execute tests            [lazy-idris responsibility]
    │   │       ./build/exec/audit-tests
    │   │       → Generates audit-tests.ss.html
    │   │
    │   └── 5c. Analyze coverage         [idris2-coverage]
    │           parseBranchCoverage(html)
    │           generateBranchHints(summary)
    │           → Branch coverage + hints
    │
    └── Step 6-7: Orphan checks
```

### Integration Code

```idris
-- In lazy-idris Audit/TIParity.idr

import Coverage.Collector
import Coverage.TestHint

computeBranchCoverage : String -> String -> IO BranchCoverageSummary
computeBranchCoverage htmlPath ssPath = do
  Right html <- readFile htmlPath | Left _ => pure emptySummary
  Right ss <- readFile ssPath | Left _ => pure emptySummary

  let funcDefs = parseSchemeDefs ss
  let branchPoints = parseBranchCoverage html
  pure $ summarizeBranchCoverageWithFunctions funcDefs branchPoints

-- In audit step
when (shouldRunStep StepCodeCoverage opts.steps) $ do
  -- Assumes .ss.html was generated during test execution
  summary <- computeBranchCoverage "audit-tests.ss.html"
                                   "build/exec/audit-tests_app/audit-tests.ss"
  let hints = generateBranchHints summary
  putStrLn $ "Branch Coverage: " ++ show summary.branchPercent ++ "%"
  putStrLn $ branchHintsToText (summarizeBranchHints hints)
```

## Project Structure

```
src/
├── Main.idr                 # CLI entry point
└── Coverage/
    ├── Types.idr            # Core data types (TestResult, TestCoverageReport, etc.)
    ├── UnifiedRunner.idr    # High-level API: runTestsWithCoverage
    ├── Collector.idr        # .ss.html parsing, branch detection
    ├── Aggregator.idr       # Coverage aggregation
    ├── Report.idr           # JSON/Text output generation
    ├── TestHint.idr         # Hint generation for uncovered code
    ├── SourceAnalyzer.idr   # Idris source analysis
    ├── TestRunner.idr       # Test execution utilities
    ├── Linearity.idr        # QTT linearity analysis
    ├── TypeAnalyzer.idr     # Type signature parsing
    ├── StateSpace.idr       # State space calculation
    ├── PathAnalysis.idr     # Path reachability analysis
    ├── Complexity.idr       # Complexity metrics
    └── Tests/
        └── AllTests.idr     # 87 unit tests
```

## Limitations

1. **Chez Scheme Only**: Currently only supports Chez Scheme backend profiler output.

2. **Heuristic Branch Detection**: Branch coverage uses pattern matching on Scheme constructs, which may miss some edge cases.

3. **No Source Mapping**: Function names are Scheme-mangled (e.g., `PreludeC-45Types-...`). Full Idris source mapping requires additional integration.

4. **Unified Runner Requirements**: Test modules must export `runAllTests : IO ()` and output `[PASS]/[FAIL]` format.

## Running Tests

```bash
idris2 --build idris2-coverage.ipkg
# Tests are in src/Coverage/Tests/
```

## License

MIT
