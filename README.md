# idris2-coverage

**Analysis library** for Idris2 code coverage. Parses Chez Scheme profiler output to extract expression coverage, branch coverage, and generate actionable test hints.

> **Important**: This is an **analysis-only** library. It does NOT run tests or generate profile data. The caller (e.g., lazy-idris) must handle test execution with profiling enabled.

## What This Library Does

```
┌─────────────────────────────────────────────────────────────┐
│                    YOUR TEST RUNNER                          │
│  (lazy-idris, custom script, CI pipeline, etc.)             │
├─────────────────────────────────────────────────────────────┤
│  1. Compile with --profile    → idris2 --build --profile    │
│  2. Execute tests             → ./build/exec/mytest         │
│  3. Chez Scheme generates     → mytest.ss.html              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    idris2-coverage                           │
│  (THIS LIBRARY)                                              │
├─────────────────────────────────────────────────────────────┤
│  Input:  .ss.html file (annotated Scheme source)            │
│  Output:                                                     │
│    • Expression coverage (73.7%)                            │
│    • Branch coverage (33.6%)                                │
│    • Actionable test hints                                  │
│    • JSON/Text reports                                       │
└─────────────────────────────────────────────────────────────┘
```

## Features

- **Expression Coverage**: Per-expression execution counts from Chez Scheme profiler
- **Branch Coverage**: Analyzes `if`/`case`/`cond` constructs to find untested paths
- **Test Hints**: Generates actionable suggestions for improving coverage
- **Function Mapping**: Associates Scheme code back to Idris function names
- **JSON/Text Output**: Machine-readable and human-readable formats

## Requirements

- Idris2 0.8.0+
- Chez Scheme 10.0+ (for profile data generation)

## Installation

```bash
git clone https://github.com/user/idris2-coverage
cd idris2-coverage
idris2 --build idris2-coverage.ipkg
```

## Integration Guide

### Step 1: Generate Profile Data (Your Responsibility)

idris2-coverage **requires** a `.ss.html` file generated by Chez Scheme's profiler.

```bash
# Build your test module with profiling enabled
idris2 --build myproject.ipkg --cg chez --profile

# Run the executable (this generates .ss.html)
./build/exec/mytest

# Result: mytest.ss.html in current directory
```

The `.ss.html` file contains annotated Scheme source with execution counts:
```html
<span class=pc2 title="line 42 char 3 count 15">(if condition ...</span>
```

### Step 2: Analyze with idris2-coverage

#### As a Library (Recommended)

```idris
import Coverage.Types
import Coverage.Collector
import Coverage.TestHint

analyzeCoverage : String -> String -> IO ()
analyzeCoverage ssHtmlPath ssPath = do
  -- Read files
  Right html <- readFile ssHtmlPath | Left _ => putStrLn "Error"
  Right ss <- readFile ssPath | Left _ => putStrLn "Error"

  -- Parse function definitions (for mapping)
  let funcDefs = parseSchemeDefs ss

  -- Parse branch coverage
  let branchPoints = parseBranchCoverage html
  let summary = summarizeBranchCoverageWithFunctions funcDefs branchPoints

  -- Generate hints
  let hints = generateBranchHints summary
  let hintSummary = summarizeBranchHints hints

  -- Output
  putStrLn $ "Branch Coverage: " ++ show summary.branchPercent ++ "%"
  putStrLn $ branchHintsToText hintSummary
```

#### As a CLI Tool

```bash
# Generate JSON report
./build/exec/idris2-cov --format json --output coverage.json mytest.ss.html

# Generate text report
./build/exec/idris2-cov --format text mytest.ss.html
```

## API Reference

### Core Types

```idris
-- Branch coverage types
data BranchType = IfBranch | CaseBranch | CondBranch

record BranchPoint where
  line, char      : Nat
  branchType      : BranchType
  totalBranches   : Nat        -- 2 for if, N for case/cond
  coveredBranches : Nat
  branchDetails   : List (String, Nat)

record BranchCoverageSummary where
  totalBranchPoints : Nat
  totalBranches     : Nat
  coveredBranches   : Nat
  branchPercent     : Double
  uncoveredBranches : List (String, BranchPoint)  -- (funcName, point)

-- Test hint types
record BranchHint where
  schemeFunc     : String      -- Function name
  branchLine     : Nat         -- Line in Scheme source
  branchType     : String      -- "if", "case", "cond"
  uncoveredPath  : String      -- "else-branch not taken"
  suggestedInput : String      -- "Provide input where condition is FALSE"
  priority       : HintPriority
  rationale      : String
```

### Parsing Functions

```idris
-- From Coverage.Collector

-- Parse Scheme function definitions (for name mapping)
parseSchemeDefs : String -> List (String, Nat)

-- Parse branch coverage from annotated HTML
parseBranchCoverage : String -> List BranchPoint

-- Summarize without function name mapping
summarizeBranchCoverage : List BranchPoint -> BranchCoverageSummary

-- Summarize with function name mapping (recommended)
summarizeBranchCoverageWithFunctions : List (String, Nat) -> List BranchPoint -> BranchCoverageSummary
```

### Hint Generation

```idris
-- From Coverage.TestHint

-- Generate hints from coverage summary
generateBranchHints : BranchCoverageSummary -> List BranchHint

-- Summarize hints by priority
summarizeBranchHints : List BranchHint -> BranchHintSummary

-- Output formats
branchHintsToText : BranchHintSummary -> String
branchHintsToJson : List BranchHint -> String
branchHintToJson  : BranchHint -> String
```

### Report Generation

```idris
-- From Coverage.Report

branchCoverageSummaryJson : BranchCoverageSummary -> String
branchPointJson : BranchPoint -> String

-- From Coverage.Aggregator
aggregateProjectWithBranches : List ModuleCoverage -> BranchCoverageSummary -> ProjectCoverage
```

## Output Formats

### Branch Coverage Summary (JSON)

```json
{
  "total_branch_points": 217,
  "total_branches": 446,
  "covered_branches": 150,
  "branch_percent": 33.63
}
```

### Branch Hint (JSON)

```json
{
  "function": "PreludeC-45Types-u--foldr_Foldable_List",
  "line": 732,
  "branch_type": "if",
  "uncovered_path": "else-branch not taken",
  "suggested_input": "Provide input where condition is FALSE",
  "priority": "IMPORTANT",
  "rationale": "The false-case of this if expression was never executed"
}
```

### Human-Readable Output

```
=== Branch Coverage Improvement Hints ===

Uncovered branches: 56

--- IMPORTANT (should fix) ---
  * blodwen-lazy (line 43)
    Problem: else-branch not taken
    Solution: Provide input where condition is FALSE

  * PreludeC-45Types-u--foldr_Foldable_List (line 732)
    Problem: else-branch not taken
    Solution: Provide input where condition is FALSE
```

## Integration Example: lazy-idris

lazy-idris uses idris2-coverage for TI Parity (Test-Implementation Parity) checks.

### Data Flow

```
lazy-idris audit
    │
    ├── Step 1-4: ST/SI Parity checks
    │
    ├── Step 5: TI Parity (Code Coverage)
    │   │
    │   ├── 5a. Build with profiling     [lazy-idris responsibility]
    │   │       idris2 --build --cg chez --profile
    │   │
    │   ├── 5b. Execute tests            [lazy-idris responsibility]
    │   │       ./build/exec/audit-tests
    │   │       → Generates audit-tests.ss.html
    │   │
    │   └── 5c. Analyze coverage         [idris2-coverage]
    │           parseBranchCoverage(html)
    │           generateBranchHints(summary)
    │           → Branch coverage + hints
    │
    └── Step 6-7: Orphan checks
```

### Integration Code

```idris
-- In lazy-idris Audit/TIParity.idr

import Coverage.Collector
import Coverage.TestHint

computeBranchCoverage : String -> String -> IO BranchCoverageSummary
computeBranchCoverage htmlPath ssPath = do
  Right html <- readFile htmlPath | Left _ => pure emptySummary
  Right ss <- readFile ssPath | Left _ => pure emptySummary

  let funcDefs = parseSchemeDefs ss
  let branchPoints = parseBranchCoverage html
  pure $ summarizeBranchCoverageWithFunctions funcDefs branchPoints

-- In audit step
when (shouldRunStep StepCodeCoverage opts.steps) $ do
  -- Assumes .ss.html was generated during test execution
  summary <- computeBranchCoverage "audit-tests.ss.html"
                                   "build/exec/audit-tests_app/audit-tests.ss"
  let hints = generateBranchHints summary
  putStrLn $ "Branch Coverage: " ++ show summary.branchPercent ++ "%"
  putStrLn $ branchHintsToText (summarizeBranchHints hints)
```

## Project Structure

```
src/
├── Main.idr                 # CLI entry point
└── Coverage/
    ├── Types.idr            # Core data types
    ├── Collector.idr        # .ss.html parsing, branch detection
    ├── Aggregator.idr       # Coverage aggregation
    ├── Report.idr           # JSON/Text output generation
    ├── TestHint.idr         # Hint generation for uncovered code
    ├── SourceAnalyzer.idr   # Idris source analysis
    ├── TestRunner.idr       # Test execution utilities
    ├── Linearity.idr        # QTT linearity analysis
    ├── TypeAnalyzer.idr     # Type signature parsing
    ├── StateSpace.idr       # State space calculation
    ├── PathAnalysis.idr     # Path reachability analysis
    └── Complexity.idr       # Complexity metrics
```

## Limitations

1. **No Test Execution**: This library does not run tests. The caller must execute tests with Chez Scheme profiling enabled.

2. **Chez Scheme Only**: Currently only supports Chez Scheme backend profiler output.

3. **Heuristic Branch Detection**: Branch coverage uses pattern matching on Scheme constructs, which may miss some edge cases.

4. **No Source Mapping**: Function names are Scheme-mangled (e.g., `PreludeC-45Types-...`). Full Idris source mapping requires additional integration.

## Running Tests

```bash
idris2 --build idris2-coverage.ipkg
# Tests are in src/Coverage/Tests/
```

## License

MIT
